// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: connectrpc/conformance/v1/service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023-2024 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A definition of a response to be sent from a single-response endpoint.
/// Can be used to define a response for unary or client-streaming calls.
struct Connectrpc_Conformance_V1_UnaryResponseDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Response headers to send
  var responseHeaders: [Connectrpc_Conformance_V1_Header] = []

  var response: Connectrpc_Conformance_V1_UnaryResponseDefinition.OneOf_Response? = nil

  /// Response data to send
  var responseData: Data {
    get {
      if case .responseData(let v)? = response {return v}
      return Data()
    }
    set {response = .responseData(newValue)}
  }

  /// Error to raise instead of response message
  /// Servers should build a RequestInfo and append it to the details of the
  /// requested error.
  var error: Connectrpc_Conformance_V1_Error {
    get {
      if case .error(let v)? = response {return v}
      return Connectrpc_Conformance_V1_Error()
    }
    set {response = .error(newValue)}
  }

  /// Response trailers to send - together with the error if present
  var responseTrailers: [Connectrpc_Conformance_V1_Header] = []

  /// Wait this many milliseconds before sending a response message
  var responseDelayMs: UInt32 = 0

  /// This field is only used by the reference server. If you are implementing a
  /// server under test, you can ignore this field or respond with an error if the
  /// server receives a request where it is set.
  ///
  /// For test definitions, this field should be used instead of the above fields.
  var rawResponse: Connectrpc_Conformance_V1_RawHTTPResponse {
    get {return _rawResponse ?? Connectrpc_Conformance_V1_RawHTTPResponse()}
    set {_rawResponse = newValue}
  }
  /// Returns true if `rawResponse` has been explicitly set.
  var hasRawResponse: Bool {return self._rawResponse != nil}
  /// Clears the value of `rawResponse`. Subsequent reads from it will return its default value.
  mutating func clearRawResponse() {self._rawResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    /// Response data to send
    case responseData(Data)
    /// Error to raise instead of response message
    /// Servers should build a RequestInfo and append it to the details of the
    /// requested error.
    case error(Connectrpc_Conformance_V1_Error)

  #if !swift(>=4.1)
    static func ==(lhs: Connectrpc_Conformance_V1_UnaryResponseDefinition.OneOf_Response, rhs: Connectrpc_Conformance_V1_UnaryResponseDefinition.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.responseData, .responseData): return {
        guard case .responseData(let l) = lhs, case .responseData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _rawResponse: Connectrpc_Conformance_V1_RawHTTPResponse? = nil
}

/// A definition of responses to be sent from a streaming endpoint.
/// Can be used to define responses for server-streaming or bidi-streaming calls.
struct Connectrpc_Conformance_V1_StreamResponseDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Response headers to send
  var responseHeaders: [Connectrpc_Conformance_V1_Header] = []

  /// Response data to send
  var responseData: [Data] = []

  /// Wait this many milliseconds before sending each response message
  var responseDelayMs: UInt32 = 0

  /// Optional error to raise, but only after sending any response messages.
  /// In the event an immediate error is thrown before any responses are sent,
  /// (i.e. the equivalent of a trailers-only response), then servers should
  /// build a RequestInfo message with available information and append that to
  /// the error details.
  var error: Connectrpc_Conformance_V1_Error {
    get {return _error ?? Connectrpc_Conformance_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  /// Response trailers to send - together with the error if present
  var responseTrailers: [Connectrpc_Conformance_V1_Header] = []

  /// This field is only used by the reference server. If you are implementing a
  /// server under test, you can ignore this field or respond with an error if the
  /// server receives a request where it is set.
  ///
  /// For test definitions, this field should be used instead of the above fields.
  var rawResponse: Connectrpc_Conformance_V1_RawHTTPResponse {
    get {return _rawResponse ?? Connectrpc_Conformance_V1_RawHTTPResponse()}
    set {_rawResponse = newValue}
  }
  /// Returns true if `rawResponse` has been explicitly set.
  var hasRawResponse: Bool {return self._rawResponse != nil}
  /// Clears the value of `rawResponse`. Subsequent reads from it will return its default value.
  mutating func clearRawResponse() {self._rawResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: Connectrpc_Conformance_V1_Error? = nil
  fileprivate var _rawResponse: Connectrpc_Conformance_V1_RawHTTPResponse? = nil
}

struct Connectrpc_Conformance_V1_UnaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response definition which should be returned in the conformance payload
  var responseDefinition: Connectrpc_Conformance_V1_UnaryResponseDefinition {
    get {return _responseDefinition ?? Connectrpc_Conformance_V1_UnaryResponseDefinition()}
    set {_responseDefinition = newValue}
  }
  /// Returns true if `responseDefinition` has been explicitly set.
  var hasResponseDefinition: Bool {return self._responseDefinition != nil}
  /// Clears the value of `responseDefinition`. Subsequent reads from it will return its default value.
  mutating func clearResponseDefinition() {self._responseDefinition = nil}

  /// Additional data. Only used to pad the request size to test large request messages.
  var requestData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _responseDefinition: Connectrpc_Conformance_V1_UnaryResponseDefinition? = nil
}

struct Connectrpc_Conformance_V1_UnaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The conformance payload to respond with.
  var payload: Connectrpc_Conformance_V1_ConformancePayload {
    get {return _payload ?? Connectrpc_Conformance_V1_ConformancePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Connectrpc_Conformance_V1_ConformancePayload? = nil
}

struct Connectrpc_Conformance_V1_IdempotentUnaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response definition which should be returned in the conformance payload
  var responseDefinition: Connectrpc_Conformance_V1_UnaryResponseDefinition {
    get {return _responseDefinition ?? Connectrpc_Conformance_V1_UnaryResponseDefinition()}
    set {_responseDefinition = newValue}
  }
  /// Returns true if `responseDefinition` has been explicitly set.
  var hasResponseDefinition: Bool {return self._responseDefinition != nil}
  /// Clears the value of `responseDefinition`. Subsequent reads from it will return its default value.
  mutating func clearResponseDefinition() {self._responseDefinition = nil}

  /// Additional data. Only used to pad the request size to test large request messages.
  var requestData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _responseDefinition: Connectrpc_Conformance_V1_UnaryResponseDefinition? = nil
}

struct Connectrpc_Conformance_V1_IdempotentUnaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The conformance payload to respond with.
  var payload: Connectrpc_Conformance_V1_ConformancePayload {
    get {return _payload ?? Connectrpc_Conformance_V1_ConformancePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Connectrpc_Conformance_V1_ConformancePayload? = nil
}

struct Connectrpc_Conformance_V1_ServerStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The response definition which should be returned in the conformance payload.
  var responseDefinition: Connectrpc_Conformance_V1_StreamResponseDefinition {
    get {return _responseDefinition ?? Connectrpc_Conformance_V1_StreamResponseDefinition()}
    set {_responseDefinition = newValue}
  }
  /// Returns true if `responseDefinition` has been explicitly set.
  var hasResponseDefinition: Bool {return self._responseDefinition != nil}
  /// Clears the value of `responseDefinition`. Subsequent reads from it will return its default value.
  mutating func clearResponseDefinition() {self._responseDefinition = nil}

  /// Additional data. Only used to pad the request size to test large request messages.
  var requestData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _responseDefinition: Connectrpc_Conformance_V1_StreamResponseDefinition? = nil
}

struct Connectrpc_Conformance_V1_ServerStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The conformance payload to respond with
  var payload: Connectrpc_Conformance_V1_ConformancePayload {
    get {return _payload ?? Connectrpc_Conformance_V1_ConformancePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Connectrpc_Conformance_V1_ConformancePayload? = nil
}

struct Connectrpc_Conformance_V1_ClientStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tells the server how to reply once all client messages are
  /// complete. Required in the first message in the stream, but
  /// should be ignored in subsequent messages.
  var responseDefinition: Connectrpc_Conformance_V1_UnaryResponseDefinition {
    get {return _responseDefinition ?? Connectrpc_Conformance_V1_UnaryResponseDefinition()}
    set {_responseDefinition = newValue}
  }
  /// Returns true if `responseDefinition` has been explicitly set.
  var hasResponseDefinition: Bool {return self._responseDefinition != nil}
  /// Clears the value of `responseDefinition`. Subsequent reads from it will return its default value.
  mutating func clearResponseDefinition() {self._responseDefinition = nil}

  /// Additional data for subsequent messages in the stream. Also
  /// used to pad the request size to test large request messages.
  var requestData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _responseDefinition: Connectrpc_Conformance_V1_UnaryResponseDefinition? = nil
}

struct Connectrpc_Conformance_V1_ClientStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The conformance payload to respond with
  var payload: Connectrpc_Conformance_V1_ConformancePayload {
    get {return _payload ?? Connectrpc_Conformance_V1_ConformancePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Connectrpc_Conformance_V1_ConformancePayload? = nil
}

struct Connectrpc_Conformance_V1_BidiStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tells the server how to reply; required in the first message
  /// in the stream. Should be ignored in subsequent messages.
  var responseDefinition: Connectrpc_Conformance_V1_StreamResponseDefinition {
    get {return _responseDefinition ?? Connectrpc_Conformance_V1_StreamResponseDefinition()}
    set {_responseDefinition = newValue}
  }
  /// Returns true if `responseDefinition` has been explicitly set.
  var hasResponseDefinition: Bool {return self._responseDefinition != nil}
  /// Clears the value of `responseDefinition`. Subsequent reads from it will return its default value.
  mutating func clearResponseDefinition() {self._responseDefinition = nil}

  /// Tells the server whether it should wait for each request
  /// before sending a response.
  ///
  /// If true, it indicates the server should effectively interleave the
  /// stream so messages are sent in request->response pairs.
  ///
  /// If false, then the response stream will be sent once all request messages
  /// are finished sending with the only delays between messages
  /// being the optional fixed milliseconds defined in the response
  /// definition.
  ///
  /// This field is only relevant in the first message in the stream
  /// and should be ignored in subsequent messages.
  var fullDuplex: Bool = false

  /// Additional data for subsequent messages in the stream. Also
  /// used to pad the request size to test large request messages.
  var requestData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _responseDefinition: Connectrpc_Conformance_V1_StreamResponseDefinition? = nil
}

struct Connectrpc_Conformance_V1_BidiStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The conformance payload to respond with
  var payload: Connectrpc_Conformance_V1_ConformancePayload {
    get {return _payload ?? Connectrpc_Conformance_V1_ConformancePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Connectrpc_Conformance_V1_ConformancePayload? = nil
}

struct Connectrpc_Conformance_V1_UnimplementedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Connectrpc_Conformance_V1_UnimplementedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Connectrpc_Conformance_V1_ConformancePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Any response data specified in the response definition to the server should be
  /// echoed back here.
  var data: Data = Data()

  /// Echoes back information about the request stream observed so far.
  var requestInfo: Connectrpc_Conformance_V1_ConformancePayload.RequestInfo {
    get {return _requestInfo ?? Connectrpc_Conformance_V1_ConformancePayload.RequestInfo()}
    set {_requestInfo = newValue}
  }
  /// Returns true if `requestInfo` has been explicitly set.
  var hasRequestInfo: Bool {return self._requestInfo != nil}
  /// Clears the value of `requestInfo`. Subsequent reads from it will return its default value.
  mutating func clearRequestInfo() {self._requestInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RequestInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The server echos back the request headers it observed here.
    var requestHeaders: [Connectrpc_Conformance_V1_Header] = []

    /// The timeout observed that was included in the request. Other timeouts use a
    /// type of uint32, but we want to be lenient here to allow whatever value the RPC
    /// server observes, even if it's outside the range of uint32.
    var timeoutMs: Int64 {
      get {return _timeoutMs ?? 0}
      set {_timeoutMs = newValue}
    }
    /// Returns true if `timeoutMs` has been explicitly set.
    var hasTimeoutMs: Bool {return self._timeoutMs != nil}
    /// Clears the value of `timeoutMs`. Subsequent reads from it will return its default value.
    mutating func clearTimeoutMs() {self._timeoutMs = nil}

    /// The server should echo back all requests received.
    /// For unary and server-streaming requests, this should always contain a single request
    /// For client-streaming and half-duplex bidi-streaming, this should contain
    /// all client requests in the order received and be present in each response.
    /// For full-duplex bidirectional-streaming, this should contain all requests in the order
    /// they were received since the last sent response.
    var requests: [SwiftProtobuf.Google_Protobuf_Any] = []

    /// If present, the request used the Connect protocol and a GET method. This
    /// captures other relevant information about the request. If a server implementation
    /// is unable to populate this (due to the server framework not exposing all of these
    /// details to application code), it may be an empty message. This implies that the
    /// server framework, at a minimum, at least expose to application code whether the
    /// request used GET vs. POST.
    var connectGetInfo: Connectrpc_Conformance_V1_ConformancePayload.ConnectGetInfo {
      get {return _connectGetInfo ?? Connectrpc_Conformance_V1_ConformancePayload.ConnectGetInfo()}
      set {_connectGetInfo = newValue}
    }
    /// Returns true if `connectGetInfo` has been explicitly set.
    var hasConnectGetInfo: Bool {return self._connectGetInfo != nil}
    /// Clears the value of `connectGetInfo`. Subsequent reads from it will return its default value.
    mutating func clearConnectGetInfo() {self._connectGetInfo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timeoutMs: Int64? = nil
    fileprivate var _connectGetInfo: Connectrpc_Conformance_V1_ConformancePayload.ConnectGetInfo? = nil
  }

  struct ConnectGetInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The query params observed in the request URL.
    var queryParams: [Connectrpc_Conformance_V1_Header] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _requestInfo: Connectrpc_Conformance_V1_ConformancePayload.RequestInfo? = nil
}

/// An error definition used for specifying a desired error response
struct Connectrpc_Conformance_V1_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The error code.
  /// For a list of Connect error codes see: https://connectrpc.com/docs/protocol#error-codes
  var code: Connectrpc_Conformance_V1_Code = .unspecified

  /// If this value is absent in a test case response definition, the contents of the
  /// actual error message will not be checked. This is useful for certain kinds of
  /// error conditions where the exact message to be used is not specified, only the
  /// code.
  var message: String {
    get {return _message ?? String()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  /// Errors in Connect and gRPC protocols can have arbitrary messages
  /// attached to them, which are known as error details.
  var details: [SwiftProtobuf.Google_Protobuf_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: String? = nil
}

/// A tuple of name and values (ASCII) for a header or trailer entry.
struct Connectrpc_Conformance_V1_Header {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header/trailer name (key).
  var name: String = String()

  /// Header/trailer value. This is repeated to explicitly support headers and
  /// trailers where a key is repeated. In such a case, these values must be in
  /// the same order as which values appeared in the header or trailer block.
  var value: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RawHTTPRequest models a raw HTTP request. This can be used to craft
/// custom requests with odd properties (including certain kinds of
/// malformed requests) to test edge cases in servers.
struct Connectrpc_Conformance_V1_RawHTTPRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HTTP verb (i.e. GET , POST).
  var verb: String = String()

  /// The URI to send the request to.
  var uri: String = String()

  /// Any headers to set on the request.
  var headers: [Connectrpc_Conformance_V1_Header] = []

  /// These query params will be encoded and added to the uri before
  /// the request is sent.
  var rawQueryParams: [Connectrpc_Conformance_V1_Header] = []

  /// This provides an easier way to define a complex binary query param
  /// than having to write literal base64-encoded bytes in raw_query_params.
  var encodedQueryParams: [Connectrpc_Conformance_V1_RawHTTPRequest.EncodedQueryParam] = []

  var body: Connectrpc_Conformance_V1_RawHTTPRequest.OneOf_Body? = nil

  /// The body is a single message.
  var unary: Connectrpc_Conformance_V1_MessageContents {
    get {
      if case .unary(let v)? = body {return v}
      return Connectrpc_Conformance_V1_MessageContents()
    }
    set {body = .unary(newValue)}
  }

  /// The body is a stream, encoded using a five-byte
  /// prefix before each item in the stream.
  var stream: Connectrpc_Conformance_V1_StreamContents {
    get {
      if case .stream(let v)? = body {return v}
      return Connectrpc_Conformance_V1_StreamContents()
    }
    set {body = .stream(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    /// The body is a single message.
    case unary(Connectrpc_Conformance_V1_MessageContents)
    /// The body is a stream, encoded using a five-byte
    /// prefix before each item in the stream.
    case stream(Connectrpc_Conformance_V1_StreamContents)

  #if !swift(>=4.1)
    static func ==(lhs: Connectrpc_Conformance_V1_RawHTTPRequest.OneOf_Body, rhs: Connectrpc_Conformance_V1_RawHTTPRequest.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unary, .unary): return {
        guard case .unary(let l) = lhs, case .unary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stream, .stream): return {
        guard case .stream(let l) = lhs, case .stream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct EncodedQueryParam {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Query param name.
    var name: String = String()

    /// Query param value.
    var value: Connectrpc_Conformance_V1_MessageContents {
      get {return _value ?? Connectrpc_Conformance_V1_MessageContents()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    /// If true, the message contents will be base64-encoded and the
    /// resulting string used as the query parameter value.
    var base64Encode: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _value: Connectrpc_Conformance_V1_MessageContents? = nil
  }

  init() {}
}

/// MessageContents represents a message in a request body.
struct Connectrpc_Conformance_V1_MessageContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message data can be defined in one of three ways.
  var data: Connectrpc_Conformance_V1_MessageContents.OneOf_Data? = nil

  /// Arbitrary bytes.
  var binary: Data {
    get {
      if case .binary(let v)? = data {return v}
      return Data()
    }
    set {data = .binary(newValue)}
  }

  /// Arbitrary text.
  var text: String {
    get {
      if case .text(let v)? = data {return v}
      return String()
    }
    set {data = .text(newValue)}
  }

  /// An actual message. The message inside the Any will be
  /// serialized to the protobuf binary formats, and the
  /// resulting bytes will be the contents.
  var binaryMessage: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .binaryMessage(let v)? = data {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {data = .binaryMessage(newValue)}
  }

  /// If specified and not identity, the above data will be
  /// compressed using the given algorithm.
  var compression: Connectrpc_Conformance_V1_Compression = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The message data can be defined in one of three ways.
  enum OneOf_Data: Equatable {
    /// Arbitrary bytes.
    case binary(Data)
    /// Arbitrary text.
    case text(String)
    /// An actual message. The message inside the Any will be
    /// serialized to the protobuf binary formats, and the
    /// resulting bytes will be the contents.
    case binaryMessage(SwiftProtobuf.Google_Protobuf_Any)

  #if !swift(>=4.1)
    static func ==(lhs: Connectrpc_Conformance_V1_MessageContents.OneOf_Data, rhs: Connectrpc_Conformance_V1_MessageContents.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.binary, .binary): return {
        guard case .binary(let l) = lhs, case .binary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binaryMessage, .binaryMessage): return {
        guard case .binaryMessage(let l) = lhs, case .binaryMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// StreamContents represents a sequence of messages in a request body.
struct Connectrpc_Conformance_V1_StreamContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The messages in the stream.
  var items: [Connectrpc_Conformance_V1_StreamContents.StreamItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StreamItem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// must be in the range 0 to 255.
    var flags: UInt32 = 0

    /// if absent use actual length of payload
    var length: UInt32 {
      get {return _length ?? 0}
      set {_length = newValue}
    }
    /// Returns true if `length` has been explicitly set.
    var hasLength: Bool {return self._length != nil}
    /// Clears the value of `length`. Subsequent reads from it will return its default value.
    mutating func clearLength() {self._length = nil}

    var payload: Connectrpc_Conformance_V1_MessageContents {
      get {return _payload ?? Connectrpc_Conformance_V1_MessageContents()}
      set {_payload = newValue}
    }
    /// Returns true if `payload` has been explicitly set.
    var hasPayload: Bool {return self._payload != nil}
    /// Clears the value of `payload`. Subsequent reads from it will return its default value.
    mutating func clearPayload() {self._payload = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _length: UInt32? = nil
    fileprivate var _payload: Connectrpc_Conformance_V1_MessageContents? = nil
  }

  init() {}
}

/// RawHTTPResponse models a raw HTTP response. This can be used to craft
/// custom responses with odd properties (including certain kinds of
/// malformed responses) to test edge cases in clients.
struct Connectrpc_Conformance_V1_RawHTTPResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If status code is not specified, it will default to a 200 response code.
  var statusCode: UInt32 = 0

  /// Headers to be set on the response.
  var headers: [Connectrpc_Conformance_V1_Header] = []

  var body: Connectrpc_Conformance_V1_RawHTTPResponse.OneOf_Body? = nil

  /// The body is a single message.
  var unary: Connectrpc_Conformance_V1_MessageContents {
    get {
      if case .unary(let v)? = body {return v}
      return Connectrpc_Conformance_V1_MessageContents()
    }
    set {body = .unary(newValue)}
  }

  /// The body is a stream, encoded using a five-byte
  /// prefix before each item in the stream.
  var stream: Connectrpc_Conformance_V1_StreamContents {
    get {
      if case .stream(let v)? = body {return v}
      return Connectrpc_Conformance_V1_StreamContents()
    }
    set {body = .stream(newValue)}
  }

  /// Trailers to be set on the response.
  var trailers: [Connectrpc_Conformance_V1_Header] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Body: Equatable {
    /// The body is a single message.
    case unary(Connectrpc_Conformance_V1_MessageContents)
    /// The body is a stream, encoded using a five-byte
    /// prefix before each item in the stream.
    case stream(Connectrpc_Conformance_V1_StreamContents)

  #if !swift(>=4.1)
    static func ==(lhs: Connectrpc_Conformance_V1_RawHTTPResponse.OneOf_Body, rhs: Connectrpc_Conformance_V1_RawHTTPResponse.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unary, .unary): return {
        guard case .unary(let l) = lhs, case .unary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stream, .stream): return {
        guard case .stream(let l) = lhs, case .stream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Connectrpc_Conformance_V1_UnaryResponseDefinition: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_UnaryResponseDefinition.OneOf_Response: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_StreamResponseDefinition: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_UnaryRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_UnaryResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_IdempotentUnaryRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_IdempotentUnaryResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ServerStreamRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ServerStreamResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientStreamRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ClientStreamResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_BidiStreamRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_BidiStreamResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_UnimplementedRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_UnimplementedResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ConformancePayload: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ConformancePayload.RequestInfo: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_ConformancePayload.ConnectGetInfo: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_Error: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_Header: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_RawHTTPRequest: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_RawHTTPRequest.OneOf_Body: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_RawHTTPRequest.EncodedQueryParam: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_MessageContents: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_MessageContents.OneOf_Data: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_StreamContents: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_StreamContents.StreamItem: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_RawHTTPResponse: @unchecked Sendable {}
extension Connectrpc_Conformance_V1_RawHTTPResponse.OneOf_Body: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "connectrpc.conformance.v1"

extension Connectrpc_Conformance_V1_UnaryResponseDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnaryResponseDefinition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_headers"),
    2: .standard(proto: "response_data"),
    3: .same(proto: "error"),
    4: .standard(proto: "response_trailers"),
    6: .standard(proto: "response_delay_ms"),
    5: .standard(proto: "raw_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responseHeaders) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.response != nil {try decoder.handleConflictingOneOf()}
          self.response = .responseData(v)
        }
      }()
      case 3: try {
        var v: Connectrpc_Conformance_V1_Error?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.responseTrailers) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rawResponse) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.responseDelayMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.responseHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeaders, fieldNumber: 1)
    }
    switch self.response {
    case .responseData?: try {
      guard case .responseData(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.responseTrailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseTrailers, fieldNumber: 4)
    }
    try { if let v = self._rawResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.responseDelayMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.responseDelayMs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_UnaryResponseDefinition, rhs: Connectrpc_Conformance_V1_UnaryResponseDefinition) -> Bool {
    if lhs.responseHeaders != rhs.responseHeaders {return false}
    if lhs.response != rhs.response {return false}
    if lhs.responseTrailers != rhs.responseTrailers {return false}
    if lhs.responseDelayMs != rhs.responseDelayMs {return false}
    if lhs._rawResponse != rhs._rawResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_StreamResponseDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamResponseDefinition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_headers"),
    2: .standard(proto: "response_data"),
    3: .standard(proto: "response_delay_ms"),
    4: .same(proto: "error"),
    5: .standard(proto: "response_trailers"),
    6: .standard(proto: "raw_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responseHeaders) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.responseData) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.responseDelayMs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.responseTrailers) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._rawResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.responseHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeaders, fieldNumber: 1)
    }
    if !self.responseData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.responseData, fieldNumber: 2)
    }
    if self.responseDelayMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.responseDelayMs, fieldNumber: 3)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.responseTrailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseTrailers, fieldNumber: 5)
    }
    try { if let v = self._rawResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_StreamResponseDefinition, rhs: Connectrpc_Conformance_V1_StreamResponseDefinition) -> Bool {
    if lhs.responseHeaders != rhs.responseHeaders {return false}
    if lhs.responseData != rhs.responseData {return false}
    if lhs.responseDelayMs != rhs.responseDelayMs {return false}
    if lhs._error != rhs._error {return false}
    if lhs.responseTrailers != rhs.responseTrailers {return false}
    if lhs._rawResponse != rhs._rawResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_UnaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnaryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_definition"),
    2: .standard(proto: "request_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._responseDefinition) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.requestData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._responseDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.requestData.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_UnaryRequest, rhs: Connectrpc_Conformance_V1_UnaryRequest) -> Bool {
    if lhs._responseDefinition != rhs._responseDefinition {return false}
    if lhs.requestData != rhs.requestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_UnaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_UnaryResponse, rhs: Connectrpc_Conformance_V1_UnaryResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_IdempotentUnaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdempotentUnaryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_definition"),
    2: .standard(proto: "request_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._responseDefinition) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.requestData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._responseDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.requestData.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_IdempotentUnaryRequest, rhs: Connectrpc_Conformance_V1_IdempotentUnaryRequest) -> Bool {
    if lhs._responseDefinition != rhs._responseDefinition {return false}
    if lhs.requestData != rhs.requestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_IdempotentUnaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdempotentUnaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_IdempotentUnaryResponse, rhs: Connectrpc_Conformance_V1_IdempotentUnaryResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ServerStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_definition"),
    2: .standard(proto: "request_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._responseDefinition) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.requestData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._responseDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.requestData.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ServerStreamRequest, rhs: Connectrpc_Conformance_V1_ServerStreamRequest) -> Bool {
    if lhs._responseDefinition != rhs._responseDefinition {return false}
    if lhs.requestData != rhs.requestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ServerStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ServerStreamResponse, rhs: Connectrpc_Conformance_V1_ServerStreamResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_definition"),
    2: .standard(proto: "request_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._responseDefinition) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.requestData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._responseDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.requestData.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientStreamRequest, rhs: Connectrpc_Conformance_V1_ClientStreamRequest) -> Bool {
    if lhs._responseDefinition != rhs._responseDefinition {return false}
    if lhs.requestData != rhs.requestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ClientStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ClientStreamResponse, rhs: Connectrpc_Conformance_V1_ClientStreamResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_BidiStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BidiStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_definition"),
    2: .standard(proto: "full_duplex"),
    3: .standard(proto: "request_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._responseDefinition) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fullDuplex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.requestData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._responseDefinition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.fullDuplex != false {
      try visitor.visitSingularBoolField(value: self.fullDuplex, fieldNumber: 2)
    }
    if !self.requestData.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_BidiStreamRequest, rhs: Connectrpc_Conformance_V1_BidiStreamRequest) -> Bool {
    if lhs._responseDefinition != rhs._responseDefinition {return false}
    if lhs.fullDuplex != rhs.fullDuplex {return false}
    if lhs.requestData != rhs.requestData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_BidiStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BidiStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_BidiStreamResponse, rhs: Connectrpc_Conformance_V1_BidiStreamResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_UnimplementedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnimplementedRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_UnimplementedRequest, rhs: Connectrpc_Conformance_V1_UnimplementedRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_UnimplementedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnimplementedResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_UnimplementedResponse, rhs: Connectrpc_Conformance_V1_UnimplementedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ConformancePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConformancePayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "request_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requestInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try { if let v = self._requestInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ConformancePayload, rhs: Connectrpc_Conformance_V1_ConformancePayload) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs._requestInfo != rhs._requestInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ConformancePayload.RequestInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Connectrpc_Conformance_V1_ConformancePayload.protoMessageName + ".RequestInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_headers"),
    2: .standard(proto: "timeout_ms"),
    3: .same(proto: "requests"),
    4: .standard(proto: "connect_get_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requestHeaders) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._timeoutMs) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._connectGetInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestHeaders, fieldNumber: 1)
    }
    try { if let v = self._timeoutMs {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 3)
    }
    try { if let v = self._connectGetInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ConformancePayload.RequestInfo, rhs: Connectrpc_Conformance_V1_ConformancePayload.RequestInfo) -> Bool {
    if lhs.requestHeaders != rhs.requestHeaders {return false}
    if lhs._timeoutMs != rhs._timeoutMs {return false}
    if lhs.requests != rhs.requests {return false}
    if lhs._connectGetInfo != rhs._connectGetInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_ConformancePayload.ConnectGetInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Connectrpc_Conformance_V1_ConformancePayload.protoMessageName + ".ConnectGetInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_params"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queryParams) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queryParams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queryParams, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_ConformancePayload.ConnectGetInfo, rhs: Connectrpc_Conformance_V1_ConformancePayload.ConnectGetInfo) -> Bool {
    if lhs.queryParams != rhs.queryParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.details) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_Error, rhs: Connectrpc_Conformance_V1_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._message != rhs._message {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Header"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_Header, rhs: Connectrpc_Conformance_V1_Header) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_RawHTTPRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawHTTPRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verb"),
    2: .same(proto: "uri"),
    3: .same(proto: "headers"),
    4: .standard(proto: "raw_query_params"),
    5: .standard(proto: "encoded_query_params"),
    6: .same(proto: "unary"),
    7: .same(proto: "stream"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.verb) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rawQueryParams) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.encodedQueryParams) }()
      case 6: try {
        var v: Connectrpc_Conformance_V1_MessageContents?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unary(v)
        }
      }()
      case 7: try {
        var v: Connectrpc_Conformance_V1_StreamContents?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .stream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .stream(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.verb.isEmpty {
      try visitor.visitSingularStringField(value: self.verb, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 3)
    }
    if !self.rawQueryParams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawQueryParams, fieldNumber: 4)
    }
    if !self.encodedQueryParams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.encodedQueryParams, fieldNumber: 5)
    }
    switch self.body {
    case .unary?: try {
      guard case .unary(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .stream?: try {
      guard case .stream(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_RawHTTPRequest, rhs: Connectrpc_Conformance_V1_RawHTTPRequest) -> Bool {
    if lhs.verb != rhs.verb {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.rawQueryParams != rhs.rawQueryParams {return false}
    if lhs.encodedQueryParams != rhs.encodedQueryParams {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_RawHTTPRequest.EncodedQueryParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Connectrpc_Conformance_V1_RawHTTPRequest.protoMessageName + ".EncodedQueryParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .standard(proto: "base64_encode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.base64Encode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.base64Encode != false {
      try visitor.visitSingularBoolField(value: self.base64Encode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_RawHTTPRequest.EncodedQueryParam, rhs: Connectrpc_Conformance_V1_RawHTTPRequest.EncodedQueryParam) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.base64Encode != rhs.base64Encode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_MessageContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageContents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "binary"),
    2: .same(proto: "text"),
    3: .standard(proto: "binary_message"),
    4: .same(proto: "compression"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .binary(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .text(v)
        }
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .binaryMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .binaryMessage(v)
        }
      }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.compression) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .binary?: try {
      guard case .binary(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .text?: try {
      guard case .text(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .binaryMessage?: try {
      guard case .binaryMessage(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.compression != .unspecified {
      try visitor.visitSingularEnumField(value: self.compression, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_MessageContents, rhs: Connectrpc_Conformance_V1_MessageContents) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.compression != rhs.compression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_StreamContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamContents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_StreamContents, rhs: Connectrpc_Conformance_V1_StreamContents) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_StreamContents.StreamItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Connectrpc_Conformance_V1_StreamContents.protoMessageName + ".StreamItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .same(proto: "length"),
    3: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 1)
    }
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_StreamContents.StreamItem, rhs: Connectrpc_Conformance_V1_StreamContents.StreamItem) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs._length != rhs._length {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connectrpc_Conformance_V1_RawHTTPResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawHTTPResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_code"),
    2: .same(proto: "headers"),
    3: .same(proto: "unary"),
    4: .same(proto: "stream"),
    5: .same(proto: "trailers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.statusCode) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 3: try {
        var v: Connectrpc_Conformance_V1_MessageContents?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unary(v)
        }
      }()
      case 4: try {
        var v: Connectrpc_Conformance_V1_StreamContents?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .stream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .stream(v)
        }
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.trailers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.statusCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.statusCode, fieldNumber: 1)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 2)
    }
    switch self.body {
    case .unary?: try {
      guard case .unary(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .stream?: try {
      guard case .stream(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.trailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trailers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connectrpc_Conformance_V1_RawHTTPResponse, rhs: Connectrpc_Conformance_V1_RawHTTPResponse) -> Bool {
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.body != rhs.body {return false}
    if lhs.trailers != rhs.trailers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
